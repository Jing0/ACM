/*
 * =====================================================================================
 *
 *       Filename:  1282.c
 *
 *    Description:  
 *    Problem Description
 *    一个正整数，如果从左向右读（称之为正序数）和从右向左读（称之为倒序数）是一样的，这样的数就叫回文数。任取一个正整数，如果不是回文数，将该数与他的倒序数相加，若其和不是回文数，则重复上述步骤，一直到获得回文数为止。例如：68变成154（68+86），再变成605（154+451），最后变成1111（605+506），而1111是回文数。于是有数学家提出一个猜想：不论开始是什么正整数，在经过有限次正序数和倒序数相加的步骤后，都会得到一个回文数。至今为止还不知道这个猜想是对还是错。现在请你编程序验证之。
 *    Input
 *    每行一个正整数。
 *    特别说明：输入的数据保证中间结果小于2^31。
 *    Output
 *    对应每个输入，输出两行，一行是变换的次数，一行是变换的过程。
 *    Sample Input
 *    27228
 *    37649
 *    Sample Output
 *    3
 *    27228--->109500--->115401--->219912
 *    2
 *    37649--->132322--->355553
 *
 *        Created:  02/16/2015 02:18:15
 *       Compiler:  gcc
 *
 *         Author:  Jackie Kuo (http://jackiekuo.com), j.kuo2012@gmail.com
 *
 * =====================================================================================
 */

#include <stdio.h>
long get_p(long p){
	long q=0;
	while(p){
		q=q*10+p%10;
		p/=10;
	}
	return q;
}
int main(){
	long n,a[200];
	while(scanf("%ld",&n)!=EOF){
		int i=0,j;
		long m=0;
		while(m!=n){
			a[i++]=n;
			m=get_p(n);
			if(m==n)
				break;
			n=m+n;
		}
		printf("%d\n",i-1);
		for(j=0;j<i;++j){
			printf("%ld%s",a[j],(j==i-1)?"\n":"--->");
		}
	}
	return 0;
}
