/*
 * =====================================================================================
 *
 *       Filename:  1106.c
 *
 *    Description:  
 *    Problem Description
 *    输入一行数字，如果我们把这行数字中的‘5’都看成空格，那么就得到一行用空格分割的若干非负整数（可能有些整数以‘0’开头，这些头部的‘0’应该被忽略掉，除非这个整数就是由若干个‘0’组成的，这时这个整数就是0）。
 *    你的任务是：对这些分割得到的整数，依从小到大的顺序排序输出。
 *    Input
 *    输入包含多组测试用例，每组输入数据只有一行数字（数字之间没有空格），这行数字的长度不大于1000。  
 *    输入数据保证：分割得到的非负整数不会大于100000000；输入数据不可能全由‘5’组成。
 *    Output
 *    对于每个测试用例，输出分割得到的整数排序的结果，相邻的两个整数之间用一个空格分开，每组输出占一行。
 *    Sample Input
 *    0051231232050775
 *    Sample Output
 *    0 77 12312320
 *
 *    Created:  04/15/2014 23:38:57
 *    Compiler:  gcc
 *
 *    Author:  Jackie Kuo (http://jackiekuo.com), j.kuo2012@gmail.com
 *
 * =====================================================================================
 */

#include <stdio.h>
int main(){
	int i,j,k,sign;
	long a[510],tmp;
	char str[1002];
	while(scanf("%s",str)!=EOF){
		for(i=j=sign=0;str[i]!='\0';i++){
			if(str[i]=='5')
				sign=0;
			else{
				if(!sign){
					a[j]=str[i]-'0';
					sign=1;
				}
				else
					a[j]=a[j]*10+str[i]-'0';
				if(str[i+1]=='5'||str[i+1]=='\0')
					++j;
			}
		}
		for(i=0;i<j;i++)
			for(k=j-1;k>i;k--)
				if(a[k]<a[k-1]){
					tmp=a[k];
					a[k]=a[k-1];
					a[k-1]=tmp;
				}
		for(i=0;i<j;i++)
			printf("%ld%s",a[i],(i==j-1)?"\n":" ");
	}
	return 0;
}
